Newton.py 考察

--以下より実行結果1 ("|"より左の数字は行数であり、実際の実行結果には含まれていない)--

  ｜$ python Newton.py 
 1｜--scipy--
 2｜x_0 = 0.045511468158
 3｜x_1 = 1.9214959284
 4｜x_2 = 6.01340553683
 5｜x_3 = 8.11510125188
 6｜x_4 = 8.90448581473
 7｜time = 4.88758087158e-05
 8｜--original--
 9｜x_0 = 0.0455114681488
10｜x_1 = 1.9214959284
11｜x_2 = 6.01340553683
12｜x_3 = 8.11510125188
13｜x_4 = 8.90448581473
14｜time = 4.91142272949e-05

--以上で実行結果1終了--
--以下より実行結果2--

  ｜$ python Newton.py 
 1｜--scipy--
 2｜x_0 = 0.045511468158
 3｜x_1 = 1.9214959284
 4｜x_2 = 6.01340553683
 5｜x_3 = 8.11510125188
 6｜x_4 = 8.90448581473
 7｜time = 5.00679016113e-05
 8｜--original--
 9｜x_0 = 0.045511468158
10｜x_1 = 1.9214959284
11｜x_2 = 6.01340553683
12｜x_3 = 8.11510125188
13｜x_4 = 8.90448581473
14｜time = 8.51154327393e-05

--以上で実行結果2終了--


ニュートン法で非線形方程式の解を求める際、解に十分近い初期値を指定しなければならない。従って、二分法同様関数の形をある程度予想しておく必要がある。今回の場合5次方程式であるため、5個の解を求めるための初期値を設定する必要がある。
また、ニュートン法において計算終了の判定は計算回数もしくは許容誤差によって行われる。本課題では求めたxに対する値の絶対値が許容誤差に収まるか、指定された最大計算回数を超えると計算を終了するように実装した。

実行結果1は許容誤差 1e-7、実行結果2は許容誤差 1e-12 に設定した際の結果である。
各初期値は関数のグラフより推定し設定した。
実行結果1ではscipyを用いた場合と自作関数で計算した場合でおおよそ同じ計算時間となっていることがわかる。しかし、計算結果は多少異なっている場合があり、
scipyを用いた結果の方が正しいことがわかる。
実行結果2ではscipyを用いた場合よりも自作関数で計算した時の方が計算速度が遅いことが読み取れる。しかし、許容誤差を小さくした分計算結果の
精度はよくなっており、scipyを用いた場合と同じ結果となっている。

・二分法との比較
二分法は指定した区間の中に解が存在し連続であれば必ず収束するが、ニュートン法の場合初期値が悪いと収束しないことがある為、初期値が解に十分近い必要がある。
また、二分法の場合は計算された区間の間に解が必ず存在するため、計算結果のおよその精度がわかる。
二分法は区間を毎回半分にするという計算方法から1次収束であるが、ニュートン法は誤差が2乗、4乗、8乗・・と小さくなり2次収束である。
従って、収束が早く計算回数も少なくなり、二分法に比べて計算時間が短くなると考えられる。実際、前回の二分法の計算結果と比べると約1/5程の計算時間となっている。


