Newton_2.py 考察

--以下より実行結果1 ("|"より左の数字は行数であり、実際の実行結果には含まれていない)--

  ｜$ python3 Newton_2.py 
 1｜--scipy--
 2｜x_0 = 0.8260313576541869, y_0 = 0.5636241621612585, n = 6
 3｜x_1 = -0.826031357654187, y_1 = -0.5636241621612585, n = 6
 4｜time = 0.005944728851318359
 5｜
 6｜--original--
 7｜x_0 = 0.8260313577324098, y_0 = 0.56362416213163, n = 4
 8｜x_1 = -0.8260313577324098, y_1 = -0.56362416213163, n = 4
 9｜time = 4.696846008300781e-05

--以上で実行結果1終了--
--以下より実行結果2--

  ｜$ python3 Newton_2.py 
 1｜--scipy--
 2｜x_0 = 0.8260313576541869, y_0 = 0.5636241621612585, n = 7
 3｜x_1 = -0.826031357654187, y_1 = -0.5636241621612585, n = 7
 4｜time = 0.008944988250732422
 5｜
 6｜--original--
 7｜x_0 = 0.826031357654187, y_0 = 0.5636241621612585, n = 6
 8｜x_1 = -0.826031357654187, y_1 = -0.5636241621612585, n = 6
 9｜time = 8.606910705566406e-05

--以上で実行結果2終了--


本問題は、ヤコビアンを用いたニュートン法(多変数)によって解を求めた。本問題ではこの解法を用いることができたが、ニュートン法を実行するにあたってヤコビアンの逆行列を
求める必要がある為、逆行列を求められない=重根の場合はこの方法を用いて計算することはできない。
また、scipyの方はNewton-Krylov法を用いて計算した。ヤコビ逆行列の計算にkrylov部分空間法を用いており、ユーザはヤコビアン及びその逆行列を計算する必要がない。
今回は実数解のみ求めたが、複素数解を求めようとするとより複雑な計算が必要になると予想される。

実行結果1は許容誤差 1e-5、実行結果2は許容誤差 1e-12 に設定した際の結果である。
各初期値は関数のグラフより推定し設定した。
実行結果1ではscipyを用いた場合と自作関数で計算した場合で、計算結果が途中の桁から異なっており、scipyを用いた結果の方が正しいことがわかる。
自作関数の結果が異なるのは、許容誤差が大きい為であると考えられ、許容誤差を小さくした実行結果2では、同じ計算結果となっている。
実行結果1及び実行結果2において、いずれもscipyを用いた場合よりも自作関数で計算した時の方が計算速度が速く、反復回数も少なくなっている。
これは、scipyは適用できる問題が多く、大規模な問題でも解決できるような一般化されたソルバである為と考えられる。自作関数はあくまで2元非線形連立方程式であるという仮定のもと
作成してあるので、今回のような問題を解く場合には優れているが、さらに複雑な問題には対応できない。一方scipyの方はより複雑であっても同様の方法で解くことができる。
従って、ある程度条件が固定(今回であれば2元非線形)されていればライブラリを用いるより速く計算できる場合があるが、複雑な問題ではライブラリを用いるのが妥当であると考えられる。



