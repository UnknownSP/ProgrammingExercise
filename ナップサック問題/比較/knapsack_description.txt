実行結果1 knapsack_Compare.py
実行結果2 knapsack_DP.py
実行結果3 knapsack_DP_numpy.py

--以下より実行結果1 ("|"より左の数字は行数であり、実際の実行結果には含まれていない)--

  ｜$ python knapsack_Compare.py 
 1｜
 2｜N = 3000
 3｜Capacity = 500
 4｜Weight Range : 10 - 99
 5｜Price Range : 1 - 1000
 6｜
 7｜--Use DP--
 8｜MaxPrice : 39606
 9｜Choice : [23, 57, 82, 89, 134, 471, 475, 484, 486, 510, 655, 862, 890, 932, 985, 994, 1045, 1051, 1064, 1097, 1134, 1214, 1394, 1423, 1491, 1557, 1593, 1650, 1691, 1880, 1972, 2035, 2105, 2107, 2162, 2170, 2206, 2215, 2719, 2810, 2838, 2854, 2861, 2931]
10｜time : 0.886584997177124 [s]
11｜
12｜--Use DP NumPy--
13｜MaxPrice : 39606
14｜time : 0.043627023696899414 [s]
15｜
16｜--Use BB--
17｜MaxPrice : 39606
18｜time : 0.21729302406311035 [s]

--以上で実行結果1終了--

--以下より実行結果2 ("|"より左の数字は行数であり、実際の実行結果には含まれていない)--

  ｜$ python knapsack_DP.py 
 1｜
 2｜N = 100000
 3｜Capacity = 500
 4｜Weight Range : 10 - 99
 5｜Price Range : 1 - 1000
 6｜
 7｜--Use DP--
 8｜MaxPrice : 49075
 9｜Choice : [505, 5990, 8656, 14077, 21328, 22210, 23830, 25912, 27958, 31132, 32500, 34152, 36859, 37567, 39201, 43358, 44176, 46223, 46310, 46338, 46618, 51733, 53250, 54083, 54151, 55331, 56746, 58588, 58605, 60897, 61052, 63125, 65736, 70763, 70926, 71289, 74439, 75132, 77059, 77253, 77479, 77501, 79725, 80868, 86903, 90938, 91258, 93490, 98745, 99407]
10｜time : 227.09454894065857 [s]
11｜
12｜--Use DP NumPy--
13｜MaxPrice : 49075
14｜time : 1.424306869506836 [s]

--以上で実行結果2終了--

--以下より実行結果3 ("|"より左の数字は行数であり、実際の実行結果には含まれていない)--

  ｜$ python knapsack_DP_numpy.py 
 1｜
 2｜N = 20000000
 3｜Capacity = 500
 4｜Weight Range : 10 - 99
 5｜Price Range : 1 - 100000
 6｜
 7｜--Use DP NumPy--
 8｜MaxPrice : 4999498
 9｜time : 288.03588104248047 [s]

--以上で実行結果3終了--


説明:

knapsack_Compare.py　では、動的計画法(以下1、動的計画法1)と、numpyのndarray.max()を用いた動的計画法(以下、動的計画法2)、分岐限定法でナップサック問題を解いて計算時間を求めている。
実行結果1より、N=3000のとき、動的計画法2、分岐限定法、動的計画法1の順で計算速度が早かった。
しかし、N=10000程度にすると、分岐限定法では計算が止まってしまった。これは、再帰回数が多くなり計算量が増えた為と考えられる。
従って、分岐限定法以外の2つの計算方法で計算時間を比較した。
実行結果2より、N=100000とすると、動的計画法1では計算時間が約4分程度かかってしまっているが、動的計画法2では約1秒で解けている。
よって、動的計画法2が一番計算時間が早いことがわかったので、動的計画法2を用いて5分程度で計算できるようにNを増やして計算していく。
ただし、価値の範囲が狭いと重さと価値をランダムに選んでいることから最大値が張り付いてしまうと考えられるので、価値の最大値を1000から100000に変更した。
実行結果3より、N=20000000としても動的計画法2の場合約5分程度で解けていることがわかる。

以上より、Nが大きくても動的計画法を用いるとある程度現実的な時間で解けることがわかった。ナップサック問題の場合は現実的な問題に置き換えてもそこまでNが大きくなるようなことはないと考えられるので、
動的計画法を上手く用いれば現実の問題も解くことができると考えられる。
また、当たり前ではあるがライブラリを用いた際の計算時間が一番早いことがわかった。問題設定が特殊な場合は自分で一から記述するしかないが、
ある程度有名な問題やソルバーが存在しているものではライブラリを用いて計算時間を短縮するのも一つの手であると考える。
