knapsack.py 実行結果

--以下より実行結果1 ("|"より左の数字は行数であり、実際の実行結果には含まれていない)--

  ｜$ python3 knapsack.py 
 1｜
 2｜--Use knapsack Function--
 3｜MaxPrice : 9474.0
 4｜Choice : [1126, 1696, 2099, 3278, 4238, 4648, 5846, 6049, 9425, 9453]
 5｜time : 0.40766215324401855
 6｜
 7｜--Use DP--
 8｜MaxPrice : 9474
 9｜Choice : [1126, 1696, 2099, 3278, 4238, 4648, 5846, 6049, 9425, 9453]
10｜time : 3.9464688301086426
11｜
12｜--Use DP Reverse--
13｜MaxPrice : 9474
14｜Choice : [1126, 1696, 2099, 3278, 4238, 4648, 5846, 6049, 9425, 9453]
15｜time : 0.7405920028686523
16｜
17｜--Use DP NumPy--
18｜MaxPrice : 9474
19｜time : 0.11434507369995117

--以上で実行結果1終了--

--以下より実行結果2 ("|"より左の数字は行数であり、実際の実行結果には含まれていない)--

  ｜$ python3 knapsack.py 
 1｜
 2｜--Use knapsack Function--
 3｜MaxPrice : 9998.0
 4｜Choice : [90412, 219379, 246958, 494323, 543081, 630080, 691715, 800114, 914669, 976504]
 5｜time : 52.41279125213623
 6｜
 7｜--Use DP NumPy--
 8｜MaxPrice : 9998
 9｜time : 10.838597059249878

--以上で実行結果2終了--


説明:

1行目から4行目では、各種ライブラリをインポートしている。
11行目から13行目では、宝石の価格と重さの配列にランダムな値の要素を追加している。
15行目から18行目では、価値と重さの配列の長さが異なった場合終了、同じだった場合に個数である配列の長さを取得。
20行目から26行目では、knapsack関数を用いて最大価格と組み合わせを求め、かかった計算時間と共に表示している。
28行目から50行目では、一般的な動的計画法を用いて最大価格と組み合わせを求め、かかった計算時間と共に表示している。
52行目から74行目では、DPテーブルを逆順で計算する動的計画法を用いて最大価格と組み合わせを求め、かかった計算時間と共に表示している。
76行目から84行目では、DPテーブルを逆順で計算する動的計画法を、NumPyを用いて最大価格を求め、かかった計算時間と共に表示している。

実行結果1は、宝石の種類を10000個にした際の結果である。
実行結果1より、いずれの計算方法でも同じ最大価格が得られているので、結果は正しいと考えられる。
また、実行時間はNumPyを用いた動的計画法が一番早く、一般的な動的計画法が一番遅くなっていることがわかる。

実行結果1より、計算時間が一番短いのはNumPyを用いた動的計画法であることがわかったので、一般的な動的計画法、DPテーブルを逆順で計算する動的計画法の部分の
プログラムをコメントアウトして、NumPyを用いた動的計画法と計算確認用のknapsack関数を用いた場合のみの計算結果を表示するようにして実行する。
約10秒で計算が終わるように要素数を大きくしていくと、実行結果2より、約10秒程度では要素数を1000000個まで大きくしても計算できることがわかった。
